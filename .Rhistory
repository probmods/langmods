prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree, prior.type)))
return(prior * likelihood)
}
utt.probs = sapply(possible.utterances, FUN=eval.utt)
return(utt.probs/sum(utt.probs))
}
admissible = function(vec) {
if (any(vec < -10) || any(vec > 10)) {
return(F)
} else if (length(vec) <= 3) {
return(T)
} else {
cons = function(i) {return(vec[i] >= vec[i-1])}
neg.indices = 2:(1 + (length(vec) - 1)/2)
pos.indices = (2 + (length(vec) - 1)/2):length(vec)
if (!all(sapply(neg.indices[-1], cons))) {
return(F)
} else if (!all(sapply(pos.indices[-1], cons))) {
return(F)
} else {
return(T)
}
}
}
listener1 = function(utterance, alpha, utt.cost, n.samples, step.size, prior.type, num.adj.pairs=1, mods=F) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
sample.prob.NN = 0
dens = normalized.density.fxn(prior.type)
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
while (sample.degree.prior == 0) {
sample.degree = runif(1,-10,10)
sample.degree.prior = dens(sample.degree)
}
sample.thetas = runif(length(possible.utterances) - 1, -10, 10)
while (!admissible(c(sample.degree, sample.thetas))) {
sample.thetas = runif(length(possible.utterances) - 1, -10, 10)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
samples[1,] = sample.vec
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 2:n.samples) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
samples[i,] = sample.vec
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples-1)))
}
sim = function(prior.type, num.adj.pairs=1, step.size=.001, mods=F, plot=T, n.true.samples = 30000, burn.in=10000, lag=50) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in sim: unable to set possible utterances")
}
n.samples = burn.in + n.true.samples * lag
select.indices = round(seq(from=(burn.in+1), to=n.samples, by=lag))
#alphas = c(2, 4)
#utt.costs = c(1.5, 3)
alpha = 4
utt.cost = 2
f.sim = function(utt) {return(listener1(utt, alpha, utt.cost, n.samples, step.size, prior.type, num.adj.pairs, mods)$samples[select.indices,])}
sim.results = lapply(possible.utterances, FUN=f.sim)
if (plot) {
if (num.adj.pairs == .5) {par(mfrow=c(1,1))}
else {par(mfrow=c(2,((length(possible.utterances) - 1)/2)))}
cols = c('blue', 'green', 'red', 'black', 'orange', 'purple', 'brown')
for (i in 2:length(possible.utterances)) {
plot(density(sim.results[[i]][,1], bw='SJ'), lwd=3, col='blue', main=paste('utt = "', possible.utterances[[i]], '", prior=', prior.type, sep=''), xlab='Degree', ylab='Density', xlim=c(0,1), ylim=c(0,6), xaxs='i')
lines(density(sim.results[[i]][,i], bw='SJ'), lwd=2, col='red')
legend('topright', legend=c('prior estimate', 'posterior estimate', 'theta posterior'), text.col=c('black', 'blue', 'red'), cex=.8)
if (prior.type == 1) {
abline(a=1, b=0, lwd=3, lty=3, col='black')
} else if (prior.type != 9) {
dens = normalized.density.fxn(prior.type)
curve(dens(x), lty=3, add=T, col='black', lwd=2)
}
}
}
return(sim.results)
}
chapter.sim = sim(11)
#
# sq = seq(from=5001, to=30000*50+5000, by=50)
#
# job.talk.plot = function(property.name, theta.data, degree.data, x1, y1, x2, y2, prior, savefiles=F, ymax=7) {
#   if (!savefiles) {par(mfrow=c(2,2))}
#   for (i in 1:4) {
#     if (savefiles) {png(paste('~/Dropbox/Stanford\ job\ talk/', property.name, '-', i, '.png', sep=''), width = 600, height = 600)}
#     plot(1,1,col='white', xlim=c(0,1), ylim=c(0, ymax), xlab=property.name, ylab='Probability density', xaxt='n', xaxs='i', cex.axis=2)
#
#     if (prior == 1) {
#     	abline(a=.8, b=0, col='red', lty=4, lwd=4)
#     	text(.17, .5, expression(paste('Interp. prior, p(', theta, ')')), cex=1.5, col='red')
#     } else {
#     	abline(a=1, b=0, col='red', lty=4, lwd=4)
#     	text(.15, 1.3, expression(paste('Interp. prior, p(', theta, ')')), cex=1.5, col='red')
#     }
#
#     if (i >= 2) {
#       if (prior == 7) {curve(dnorm(x, .5, .15), col='black', add=T, lwd=4)}
#       else if (prior == 1) {abline(a=1.2, b=0, col='black', lwd=4)}
#       if (prior == 1) {
#       	text(.18, 1.6, paste(property.name, 'prior, p(f)'), cex=1.5)
#       } else {
#       	text(.3, 2.5, paste(property.name, 'prior'), cex=1.5)
#       	text(.3, 2.1, 'p(h)', cex=1.5)
#       }
#     }
#     if (i >= 3) {
#       lines(density(theta.data), col='blue', lwd=4, lty=4)
#       text(x1, y1, paste('Interp. posterior'), col='blue', cex=1.5)
#       text(x1, y1-.4, expression(paste('p(', theta, '|u)')), col='blue', cex=1.5)
#     }
#     if (i == 4) {
#       lines(density(degree.data), col='brown', lwd=4)
#       text(x2, y2, property.name, col='brown', cex=1.5)
#       text(x2, y2-.4, 'posterior', col='brown', cex=1.5)
#       if (prior == 1) {text(x2, y2-.8, paste('p(f|u)'), col='brown', cex=1.5)}
#       else {text(x2, y2-.8, paste('p(h|u)'), col='brown', cex=1.5)}
#     }
#     if (savefiles) {
#       dev.off()
#     }
#   }
# }
# job.talk.plot('Height', gaussian.prior.7.one.pair.sim[[3]][,3], gaussian.prior.7.one.pair.sim[[3]][,1], .58, 6.5, .92, 4.5, prior = 7, savefiles=T)
# job.talk.plot('Fullness', uniform.pos.only.one.pair.alpha.4[[1]][,3], uniform.pos.only.one.pair.alpha.4[[1]][,1], .72, 5, .87, 9, ymax = 10, prior = 1, savefiles=T)
#
#
#
#
# uniform.pos.only.one.pair.alpha.4[[1]][,3]
# sample.cond.prob = function(s, epsilon, eval) {
# 	cond = eval[which(eval < s)]
# 	cond.prob = function(x) {return(length(which(cond < x - epsilon))/length(cond))}
# 	return(cond.prob(s))
# }
# f = function(x) {return(sample.cond.prob(x, .01, uniform.pos.only.one.pair.alpha.4[[1]][sq,3]))}
# res = sapply(sample(uniform.pos.only.one.pair.alpha.4[[1]][sq,1], 10000, replace=T), f)
#
# # eval: uniform.pos.only.one.pair.alpha.4[[1]][sq,3]
# f2 = function(x) {return(sample.cond.prob(x, .01, gaussian.prior.7.one.pair.sim[[3]][,3]))}
# gauss.res = sapply(sample(gaussian.prior.7.one.pair.sim[[3]][,1], 10000, replace=T), f2)
#
# For handbook chapter and SALT paper. The following simulates how L0 would behave if the variable weren't passed up -- inferred meaning of 'pos' is very low, since there's no speaker-driven pressure for informativity.
# This version, it's hard-coded to work with prior from that example.
literal.only = function(n.sims) {
results = matrix(NA, nrow=n.sims, ncol=2)
accepted = 0
while (accepted < n.sims) {
theta = runif(1, -10, 10) # uniform prior on thetas over sufficient interval
height = rnorm(1, 0, 2.25)
if (height > theta) {
accepted = accepted + 1
results[accepted,] = c(height, theta)
}
}
return(results)
}
#literal.only.sim = literal.only(100000)
par(mfrow=c(1,2))
curve(dnorm(x, 0, 2.25), xlim=c(-10,10), lty=1, lwd=3, col='red', xlab='Strength', ylab='Probability density')
abline(h=.05, lty=4, lwd=3, col='black')
plot(density(literal.only.sim[,1]), col='blue', lwd=3, lty=2)
lines(density(literal.only.sim[,2]), col='green', lwd=3, lty=3)
legend('topright', c('Strength prior', 'Strength posterior', 'Degree prior', 'Degree posterior'), lty=c(1, 2, 4, 3), col=c('red', 'blue', 'black', 'green'), text.col=c('red', 'blue', 'black', 'green'), cex=.8)
normalized.density.fxn = function(prior.type) {
if (prior.type == 2) {
return(function(x) {return(dbeta(x, .5, .5))})
} else if (prior.type == 7) {
# 0.9991419 is the prob mass between 0 and 1 for this gaussian
return(function(x) {return(dnorm(x, .5, .15)/0.9991419)})
} else if (prior.type == 8) {
# 0.9522094 is the prob mass between 0 and 1 for this gaussian
return(function(x) {return(dnorm(x, .25, .15)/0.9522094)})
} else if (prior.type == 11) {
return(function(x) {return(dnorm(x, 0, .2.25))})
# all prior mass in [0,1] - rescale for examples to gaussian(0, 2.25)
} else {
return(function(x) {return(densfxn(prior.type)(x)/calc.NC(prior.type))})
}
}
if (prior.type == 11) {
return(function(x) {return(dnorm(x, 0, .2.25))})
# all prior mass in [0,1] - rescale for examples to gaussian(0, 2.25)
}
normalized.density.fxn = function(prior.type) {
if (prior.type == 2) {
return(function(x) {return(dbeta(x, .5, .5))})
} else if (prior.type == 7) {
# 0.9991419 is the prob mass between 0 and 1 for this gaussian
return(function(x) {return(dnorm(x, .5, .15)/0.9991419)})
} else if (prior.type == 8) {
# 0.9522094 is the prob mass between 0 and 1 for this gaussian
return(function(x) {return(dnorm(x, .25, .15)/0.9522094)})
} else if (prior.type == 11) {
return(function(x) {return(dnorm(x, 0, 2.25))})
# all prior mass in [0,1] - rescale for examples to gaussian(0, 2.25)
} else {
return(function(x) {return(densfxn(prior.type)(x)/calc.NC(prior.type))})
}
}
chapter.sim = sim(11)
?sample
genders = sample(c(0,1), 4, replace=T)
genders
gender.str = rnorm(2, 0, 2)
gender.str
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
approx.equal = function(x,y) return(abs(x - y) < .01)
approx.equal(1, 1.01)
approx.equal(1, 1.001)
accepted = 0
n.sims = 1000
all(T, T, T)
all(T, T, T, F)
observed.strengths = c(-1.1, .5, -.3, .7)
return(abs(v1[i] - v2[i]) < .01)})))
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .01)})))}
approx.equal(c(1,2,3,4), c(1.001, 2.001, 3.001, 4.001))
approx.equal(c(1,2,3,4), c(1.001, 2.021, 3.001, 4.001))
observed.strengths = c(-1.1, .5, -.3, .7)
results = rep(NA, n.sims)
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {return(rnorm(1, gender.str[g], 1))})
if ()) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
simulated.strengths
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths))) {
accepted = accepted + 1
results[accepted] = genders[4]
}
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
approx.equal(observed.strengths, simulated.strengths)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
accepted = 0
n.sims = 13
results = rep(NA, n.sims)
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .01)})))}
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
accepted = 0
n.sims = 3
results = rep(NA, n.sims)
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .01)})))}
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
accepted = 0
n.sims = 4
results = rep(NA, n.sims)
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .1)})))}
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = sample(c(1,2), 4, replace=T) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
genders
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
genders
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
genders
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
genders
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
genders
accepted = 0
n.sims = 4
results = rep(NA, n.sims)
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .1)})))}
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
accepted = 0
n.sims = 4
results = rep(NA, n.sims)
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .3)})))}
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
results
accepted = 0
n.sims = 100
results = rep(NA, n.sims)
approx.equal = function(v1,v2) {return(all(sapply(1:length(v1),
FUN=function(i) {
return(abs(v1[i] - v2[i]) < .2)})))}
observed.strengths = c(-1.1, .5, -.3, .7)
while (accepted < n.sims) {
gender.str = rnorm(2, 0, 2)
genders = c(1, 2, 1, sample(c(1,2), 1)) # 1='m', 2 = 'f'
# positions: bob = -1.1, jane = .5, jim = -.3, pat = .7
simulated.strengths = sapply(genders, function(g) {
return(rnorm(1, gender.str[g], 1))
})
if (approx.equal(observed.strengths, simulated.strengths)) {
accepted = accepted + 1
results[accepted] = genders[4]
}
}
fix(chapter.sim)
results
length(which(results==1))
length(which(results==2))
strong = chapter.sim[[3]]
summary(strong)
par(mfrow=c(1,2))
curve(dnorm(x, 0, 2.25), xlim=c(-10,10), lty=1, lwd=3, col='red', xlab='Strength', ylab='Probability density')
abline(h=.05, lty=4, lwd=3, col='black')
plot(density(strong[,1]), col='blue', lwd=3, lty=2)
lines(density(strong[,2]), col='green', lwd=3, lty=3)
plot(density(strong[,2]), col='green', lwd=3, lty=3)
curve(dnorm(x, 0, 2.25), xlim=c(-10,10), lty=1, lwd=3, col='red', xlab='Strength', ylab='Probability density')
abline(h=.05, lty=4, lwd=3, col='black')
lines(density(strong[,1]), col='blue', lwd=3, lty=2)
lines(density(strong[,2]), col='green', lwd=3, lty=3)
curve(dnorm(x, 0, 2.25), xlim=c(-10,10), lty=1, lwd=3, col='red', xlab='Strength', ylab='Probability density')
abline(h=.05, lty=4, lwd=3, col='black')
lines(density(strong[,1]), col='blue', lwd=3, lty=2)
lines(density(strong[,2]), col='green', lwd=3, lty=3)
curve(dnorm(x, 0, 2.25), xlim=c(-10,10), ylim=c(0, 5), lty=1, lwd=3, col='red', xlab='Strength', ylab='Probability density')
abline(h=.05, lty=4, lwd=3, col='black')
lines(density(strong[,1]), col='blue', lwd=3, lty=2)
sim = function(prior.type, num.adj.pairs=1, step.size=.001, mods=F, plot=T, n.true.samples = 30000, burn.in=10000, lag=50) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in sim: unable to set possible utterances")
}
n.samples = burn.in + n.true.samples * lag
select.indices = round(seq(from=(burn.in+1), to=n.samples, by=lag))
#alphas = c(2, 4)
#utt.costs = c(1.5, 3)
alpha = 2
utt.cost = 1.5
f.sim = function(utt) {return(listener1(utt, alpha, utt.cost, n.samples, step.size, prior.type, num.adj.pairs, mods)$samples[select.indices,])}
sim.results = lapply(possible.utterances, FUN=f.sim)
if (plot) {
if (num.adj.pairs == .5) {par(mfrow=c(1,1))}
else {par(mfrow=c(2,((length(possible.utterances) - 1)/2)))}
cols = c('blue', 'green', 'red', 'black', 'orange', 'purple', 'brown')
for (i in 2:length(possible.utterances)) {
plot(density(sim.results[[i]][,1], bw='SJ'), lwd=3, col='blue', main=paste('utt = "', possible.utterances[[i]], '", prior=', prior.type, sep=''), xlab='Degree', ylab='Density', xlim=c(0,1), ylim=c(0,6), xaxs='i')
lines(density(sim.results[[i]][,i], bw='SJ'), lwd=2, col='red')
legend('topright', legend=c('prior estimate', 'posterior estimate', 'theta posterior'), text.col=c('black', 'blue', 'red'), cex=.8)
if (prior.type == 1) {
abline(a=1, b=0, lwd=3, lty=3, col='black')
} else if (prior.type != 9) {
dens = normalized.density.fxn(prior.type)
curve(dens(x), lty=3, add=T, col='black', lwd=2)
}
}
}
return(sim.results)
}
chapter.sim = sim(11, plot=F)
sim = function(prior.type, num.adj.pairs=1, step.size=.001, mods=F, plot=T, n.true.samples = 30000, burn.in=10000, lag=50) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in sim: unable to set possible utterances")
}
n.samples = burn.in + n.true.samples * lag
select.indices = round(seq(from=(burn.in+1), to=n.samples, by=lag))
#alphas = c(2, 4)
#utt.costs = c(1.5, 3)
alpha = 1
utt.cost = 1.5
f.sim = function(utt) {return(listener1(utt, alpha, utt.cost, n.samples, step.size, prior.type, num.adj.pairs, mods)$samples[select.indices,])}
sim.results = lapply(possible.utterances, FUN=f.sim)
if (plot) {
if (num.adj.pairs == .5) {par(mfrow=c(1,1))}
else {par(mfrow=c(2,((length(possible.utterances) - 1)/2)))}
cols = c('blue', 'green', 'red', 'black', 'orange', 'purple', 'brown')
for (i in 2:length(possible.utterances)) {
plot(density(sim.results[[i]][,1], bw='SJ'), lwd=3, col='blue', main=paste('utt = "', possible.utterances[[i]], '", prior=', prior.type, sep=''), xlab='Degree', ylab='Density', xlim=c(0,1), ylim=c(0,6), xaxs='i')
lines(density(sim.results[[i]][,i], bw='SJ'), lwd=2, col='red')
legend('topright', legend=c('prior estimate', 'posterior estimate', 'theta posterior'), text.col=c('black', 'blue', 'red'), cex=.8)
if (prior.type == 1) {
abline(a=1, b=0, lwd=3, lty=3, col='black')
} else if (prior.type != 9) {
dens = normalized.density.fxn(prior.type)
curve(dens(x), lty=3, add=T, col='black', lwd=2)
}
}
}
return(sim.results)
}
chapter.sim = sim(11, plot=F, lag=10)
chapter.sim = sim(11, plot=F, lag=10, n.true.samples=10000)
