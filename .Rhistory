sample.thetas = runif(length(possible.utterances) - 1, -10, 10)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
n.samples = 1000000
sq = seq(from=1, to=n.samples, by=50)
tst2 = listener1('pos', 1, 1.5, n.samples=n.samples, step.size=.03, prior.type = 11, burn.in = 200000)[[1]][sq,]
listener1 = function(utterance, alpha, utt.cost, n.samples, step.size, prior.type, num.adj.pairs=1, mods=F, burn.in=10000) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
sample.prob.NN = 0
dens = normalized.density.fxn(prior.type)
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
n.samples = 1000000
sq = seq(from=1, to=n.samples, by=50)
tst2 = listener1('pos', 1, 1.5, n.samples=n.samples, step.size=.03, prior.type = 11, burn.in = 200000)[[1]][sq,]
par(mfrow=c(1,1))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(tst2[,1])) # degree
lines(density(tst2[,3]), col='red') #theta-pos
summary(tst2)
utterance.index('pos')
speaker1(c(-.15, -2.3), 1.18, 1, 1.5, 11)
speaker1(c(-.15, -2.3), 1.18, 2, 1.5, 11)[utterance.index(utterance)]
n.samples = 1000000
sq = seq(from=1, to=n.samples, by=50)
tst3 = listener1('pos', 1, 2.5, n.samples=n.samples, step.size=.03, prior.type = 11, burn.in = 200000)[[1]][sq,]
par(mfrow=c(1,1))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(tst3[,1])) # degree
lines(density(tst3[,3]), col='red') #theta-pos
is.true('pos', c(1, 2), 2)
is.true('pos', c(1, 2), 1)
relevant.theta('pos')
rm(list=ls())
possible.utterances = c()
normalized.density.fxn = function(prior.type) {
return(function(x) {return(dnorm(x, 0, 2.25))})
# all prior mass in [0,1] - rescale for examples to gaussian(0, 2.25)
}
prior.prob.gtr = function(theta, prior.type, polarity) {
if (polarity == 'positive') {
mu = 0
sigma = 2.25
return(1 - pnorm(theta, mu, sigma))
} else {
return(1 - prior.prob.gtr(theta, prior.type, 'positive'))
}
}
set.possible.utterances = function(num.adj.pairs, mods=F) {
if (num.adj.pairs == .5) {
possible.utterances <<- c('no-utt', 'pos')
return(T)
} else if (num.adj.pairs == 1 && !mods) {
possible.utterances <<- c('no-utt', 'neg', 'pos')
return(T)
} else if (num.adj.pairs == 2 && !mods) {
possible.utterances <<- c('no-utt', 'neg2', 'neg1', 'pos1', 'pos2')
return(T)
} else if (num.adj.pairs == 3 && !mods) {
possible.utterances <<- c('no-utt', 'neg3', 'neg2', 'neg1', 'pos1', 'pos2', 'pos3')
return(T)
} else if (num.adj.pairs == 1 && mods) {
possible.utterances <<- c('no-utt', 'very neg', 'neg', 'pos', 'very pos')
return(T)
} else {
print("Error at function set.possible.utterances: unknown number of pairs")
return(F)
}
}
approx.equal = function(x,y) {return(abs(x - y) < .00001)}
utterance.index = function(utt) {return(which(possible.utterances == utt))}
polarity = function(utterance) {
if (utterance == 'pos' || utterance == 'very pos' || utterance == 'pos1' || utterance == 'very pos1' || utterance == 'pos2' || utterance == 'pos3') {
return('positive')
} else if (utterance == 'neg' || utterance == 'very neg' || utterance == 'neg1' || utterance == 'very neg1' || utterance == 'neg2' || utterance == 'neg3') {
return('negative')
} else {
print("Error in function polarity: unknown utterance")
}
}
relevant.theta = function(utterance) {return(which(possible.utterances[-1] == utterance))}
is.true = function(utterance, thetas, degree) {
if (utterance == 'no-utt') {
return(T)
} else if (polarity(utterance) == 'positive' && degree >= thetas[relevant.theta(utterance)]) {
return(T)
} else if (polarity(utterance) == 'negative' && degree <= thetas[relevant.theta(utterance)]) {
return(T)
} else {
return(F)
}
}
listener0 = function(utterance, thetas, degree, prior.type) {
if (!is.true(utterance, thetas, degree)) {
return(0)
} else if (utterance == 'no-utt') {
return(1)
} else {
# return the prior probability of the utterance being true, as long as it isn't 0.
return(1/prior.prob.gtr(thetas[relevant.theta(utterance)], prior.type, polarity(utterance)))
}
}
mylnth = function(u) {
if (u == 'no-utt') {
return(0)
} else if (u=='very pos' || u=='very neg') {
return(2)
} else {
return(1)
}
}
speaker1 = function(thetas, degree, alpha, utt.cost, prior.type) {
eval.utt = function(utt) {
prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree, prior.type)))
return(prior * likelihood)
}
utt.probs = sapply(possible.utterances, FUN=eval.utt)
return(utt.probs/sum(utt.probs))
}
speaker1(c(-.15, -2.3), 1.18, 2, 1.5, 11)[utterance.index(utterance)]
eval.utt = function(utt) {
prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree, prior.type)))
return(prior * likelihood)
}
alpha=2
utt.cost=1.5
prior.prob.gtr = function(theta, polarity) {
if (polarity == 'positive') {
mu = 0
sigma = 2.25
return(1 - pnorm(theta, mu, sigma))
} else {
return(1 - prior.prob.gtr(theta, 'positive'))
}
}
set.possible.utterances = function(num.adj.pairs, mods=F) {
if (num.adj.pairs == .5) {
possible.utterances <<- c('no-utt', 'pos')
return(T)
} else if (num.adj.pairs == 1 && !mods) {
possible.utterances <<- c('no-utt', 'neg', 'pos')
return(T)
} else if (num.adj.pairs == 2 && !mods) {
possible.utterances <<- c('no-utt', 'neg2', 'neg1', 'pos1', 'pos2')
return(T)
} else if (num.adj.pairs == 3 && !mods) {
possible.utterances <<- c('no-utt', 'neg3', 'neg2', 'neg1', 'pos1', 'pos2', 'pos3')
return(T)
} else if (num.adj.pairs == 1 && mods) {
possible.utterances <<- c('no-utt', 'very neg', 'neg', 'pos', 'very pos')
return(T)
} else {
print("Error at function set.possible.utterances: unknown number of pairs")
return(F)
}
}
approx.equal = function(x,y) {return(abs(x - y) < .00001)}
utterance.index = function(utt) {return(which(possible.utterances == utt))}
polarity = function(utterance) {
if (utterance == 'pos' || utterance == 'very pos' || utterance == 'pos1' || utterance == 'very pos1' || utterance == 'pos2' || utterance == 'pos3') {
return('positive')
} else if (utterance == 'neg' || utterance == 'very neg' || utterance == 'neg1' || utterance == 'very neg1' || utterance == 'neg2' || utterance == 'neg3') {
return('negative')
} else {
print("Error in function polarity: unknown utterance")
}
}
relevant.theta = function(utterance) {return(which(possible.utterances[-1] == utterance))}
is.true = function(utterance, thetas, degree) {
if (utterance == 'no-utt') {
return(T)
} else if (polarity(utterance) == 'positive' && degree >= thetas[relevant.theta(utterance)]) {
return(T)
} else if (polarity(utterance) == 'negative' && degree <= thetas[relevant.theta(utterance)]) {
return(T)
} else {
return(F)
}
}
listener0 = function(utterance, thetas, degree) {
if (!is.true(utterance, thetas, degree)) {
return(0)
} else if (utterance == 'no-utt') {
return(1)
} else {
# return the prior probability of the utterance being true, as long as it isn't 0.
return(1/prior.prob.gtr(thetas[relevant.theta(utterance)], polarity(utterance)))
}
}
mylnth = function(u) {
if (u == 'no-utt') {
return(0)
} else if (u=='very pos' || u=='very neg') {
return(2)
} else {
return(1)
}
}
speaker1 = function(thetas, degree, alpha, utt.cost) {
eval.utt = function(utt) {
prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree)))
return(prior * likelihood)
}
utt.probs = sapply(possible.utterances, FUN=eval.utt)
return(utt.probs/sum(utt.probs))
}
speaker1(c(-.15, -2.3), 1.18, 2, 1.5)
eval.utt = function(utt) {
prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree)))
return(prior * likelihood)
}
alpha=2
utt.cost
eval.utt('pos')
degree=1.18
proposal.thetas=c(-.15, -2.3)
eval.utt('pos')
utt
thetas
thetas=c(-.15, -2.3)
eval.utt('pos')
utterance='pos'
polarity(utterance) == 'positive'
thetas[relevant.theta(utterance)]
set.possible.utterances(1, F)
thetas[relevant.theta(utterance)]
speaker1 = function(thetas, degree, alpha, utt.cost) {
eval.utt = function(utt) {
prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree)))
return(prior * likelihood)
}
utt.probs = sapply(possible.utterances, FUN=eval.utt)
return(utt.probs/sum(utt.probs))
}
speaker1(c(-.15, -2.3), 1.18, 2, 1.5)
admissible = function(vec) {
if (any(vec < -6) || any(vec > 6)) {
return(F)
} else {if (length(vec) <= 3) {
return(T)
}
}
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
sample.prob.NN = 0
dens = normalized.density.fxn(prior.type)
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.likelihood
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.degree.prior
sample.prob.NN
sample.prob.NN = 0
dens = normalized.density.fxn(prior.type)
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
step.size=.01
proposal.vec = make.proposal(sample.vec, switch)
proposal.vec
listener1 = function(utterance, alpha, utt.cost, n.samples, step.size, prior.type, num.adj.pairs=1, mods=F, burn.in=10000) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
sample.prob.NN = 0
dens = normalized.density.fxn(prior.type)
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost, prior.type)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
n.samples = 1000000
tst4 = listener1('pos', alpha=2, utt.cost=1.5, n.samples=n.samples, step.size=.01, prior.type = 11, burn.in = 200000)[[1]][seq(from=1, to=n.samples, by=50),]
par(mfrow=c(1,1))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(tst4[,1])) # degree
lines(density(tst4[,3]), col='red') #theta-pos
listener1 = function(utterance, alpha, utt.cost, n.samples, step.size, num.adj.pairs=1, mods=F, burn.in=10000) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
sample.prob.NN = 0
dens = function(x){return(dnorm(x, 0, 2.25))}
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = runif(1,-6,6)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
n.samples = 1000000
tst4 = listener1('pos', alpha=2, utt.cost=1.5, n.samples=n.samples, step.size=.01, burn.in = 200000)[[1]][seq(from=1, to=n.samples, by=50),]
par(mfrow=c(1,1))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(tst4[,1])) # degree
lines(density(tst4[,3]), col='red') #theta-pos
