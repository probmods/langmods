for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
dhfebsvduiv]]}
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
sample.prob.NN = 0
dens = function(x){return(dnorm(x, 0, 2.25))}
rm(list=ls())
possible.utterances = c()
prior.prob.gtr = function(theta, polarity) {
if (polarity == 'positive') {
mu = 0
sigma = 2.25
return(1 - pnorm(theta, mu, sigma))
} else {
return(1 - prior.prob.gtr(theta, 'positive'))
}
}
set.possible.utterances = function(num.adj.pairs, mods=F) {
if (num.adj.pairs == .5) {
possible.utterances <<- c('no-utt', 'pos')
return(T)
} else if (num.adj.pairs == 1 && !mods) {
possible.utterances <<- c('no-utt', 'neg', 'pos')
return(T)
} else if (num.adj.pairs == 2 && !mods) {
possible.utterances <<- c('no-utt', 'neg2', 'neg1', 'pos1', 'pos2')
return(T)
} else if (num.adj.pairs == 3 && !mods) {
possible.utterances <<- c('no-utt', 'neg3', 'neg2', 'neg1', 'pos1', 'pos2', 'pos3')
return(T)
} else if (num.adj.pairs == 1 && mods) {
possible.utterances <<- c('no-utt', 'very neg', 'neg', 'pos', 'very pos')
return(T)
} else {
print("Error at function set.possible.utterances: unknown number of pairs")
return(F)
}
}
approx.equal = function(x,y) {return(abs(x - y) < .00001)}
utterance.index = function(utt) {return(which(possible.utterances == utt))}
polarity = function(utterance) {
if (utterance == 'pos' || utterance == 'very pos' || utterance == 'pos1' || utterance == 'very pos1' || utterance == 'pos2' || utterance == 'pos3') {
return('positive')
} else if (utterance == 'neg' || utterance == 'very neg' || utterance == 'neg1' || utterance == 'very neg1' || utterance == 'neg2' || utterance == 'neg3') {
return('negative')
} else {
print("Error in function polarity: unknown utterance")
}
}
relevant.theta = function(utterance) {return(which(possible.utterances[-1] == utterance))}
is.true = function(utterance, thetas, degree) {
if (utterance == 'no-utt') {
return(T)
} else if (polarity(utterance) == 'positive' && degree >= thetas[relevant.theta(utterance)]) {
return(T)
} else if (polarity(utterance) == 'negative' && degree <= thetas[relevant.theta(utterance)]) {
return(T)
} else {
return(F)
}
}
listener0 = function(utterance, thetas, degree) {
if (!is.true(utterance, thetas, degree)) {
return(0)
} else if (utterance == 'no-utt') {
return(1)
} else {
# return the prior probability of the utterance being true, as long as it isn't 0.
return(1/prior.prob.gtr(thetas[relevant.theta(utterance)], polarity(utterance)))
}
}
mylnth = function(u) {
if (u == 'no-utt') {
return(0)
} else if (u=='very pos' || u=='very neg') {
return(2)
} else {
return(1)
}
}
speaker1 = function(thetas, degree, alpha, utt.cost) {
eval.utt = function(utt) {
prior = exp(-alpha * utt.cost)^mylnth(utt)
likelihood = exp(alpha * log(listener0(utt, thetas, degree)))
return(prior * likelihood)
}
utt.probs = sapply(possible.utterances, FUN=eval.utt)
return(utt.probs/sum(utt.probs))
}
admissible = function(vec) {
if (any(vec < -6) || any(vec > 6)) {
return(F)
} else {
return(T)
}
listener1 = function(utterance, n.samples, alpha=1, utt.cost=1.5, step.size=.02, num.adj.pairs=1, mods=F, burn.in=10000) {
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
sample.prob.NN = 0
dens = function(x){return(dnorm(x, 0, 2.25))}
while (approx.equal(sample.prob.NN,0)) {
sample.degree.prior = 0
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
while (sample.degree.prior == 0 || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = rnorm(1,0,2.25)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
}
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
}
sample.degree.prior = 0
sample.thetas = c(0,0)
admissible(c(sample.degree, sample.thetas))
sample.degree = 0
admissible(c(sample.degree, sample.thetas))
sample.degree.prior
sample.degree = 0
sample.thetas = c(0,0)
approx.equal(sample.prob.NN,0)
sample.prob.NN = 0
approx.equal(sample.prob.NN,0)
sample.degree = rnorm(1,0,2.25)
sample.degree
sample.degree.prior = dens(sample.degree)
dens = function(x){return(dnorm(x, 0, 2.25))}
sample.degree.prior
sample.degree
sample.degree.prior = dens(sample.degree)
sample.degree.prior
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
sample.thetas
length(possible.utterances)
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
num.adj.pairs = 1
mods = F
pu.check = set.possible.utterances(num.adj.pairs, mods)
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
alpha=1
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
utt.cost = 1.5
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
utterance='pos'
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.likelihood
sample.prob.NN = sample.degree.prior * sample.likelihood
sample.prob.NN
speaker1(sample.thetas, sample.degree, alpha, utt.cost)
while (approx.equal(sample.prob.NN,0) || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = rnorm(1,0,2.25)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.prob.NN
sample.thetas
sample.degree
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
listener1 = function(utterance, n.samples, alpha=1, utt.cost=1.5, step.size=.02, burn.in=10000) {
num.adj.pairs = 1
mods = F
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
dens = function(x){return(dnorm(x, 0, 2.25))}
sample.degree = 0
sample.thetas = c(0,0)
sample.prob.NN = 0
while (approx.equal(sample.prob.NN,0) || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = rnorm(1,0,2.25)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
n.samples = 100
n.samples = 100
sq = seq(from=1, to=n.samples, by=50)
tst2 = listener1('pos', n.samples, alpha=1, cost=1.5)
tst2 = listener1('pos', n.samples, alpha=1, utt.cost=1.5)
tst2
listener1 = function(utterance, n.samples, alpha=1, utt.cost=1.5, step.size=.02, burn.in=50000) {
num.adj.pairs = 1
mods = F
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
dens = function(x){return(dnorm(x, 0, 2.25))}
sample.degree = 0
sample.thetas = c(0,0)
sample.prob.NN = 0
while (approx.equal(sample.prob.NN,0) || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = rnorm(1,0,2.25)
sample.degree.prior = dens(sample.degree)
sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
n.samples = 100
sq = seq(from=1, to=n.samples, by=50)
tst2 = listener1('pos', n.samples, alpha=1, utt.cost=1.5)
tst2
n.samples = 500000
sq = seq(from=1, to=n.samples, by=50)
chain1 = listener1('pos', n.samples, alpha=1, utt.cost=1.5)[[1]][sq,]
par(mfrow=c(1,1))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain1[,1])) # degree
lines(density(chain1[,3]), col='red') #theta-pos
summary(chain)
summary(chain1)
chain2 = listener1('pos', n.samples, alpha=1, utt.cost=1.5)[[1]][sq,]
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
par(mfrow=c(1,2))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain1[,1])) # degree
lines(density(chain1[,3]), col='red') #theta-pos
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain2[,1])) # degree
lines(density(chain2[,3]), col='red') #theta-pos
listener1 = function(utterance, n.samples, alpha=1, utt.cost=1.5, step.size=.02, burn.in=50000) {
num.adj.pairs = 1
mods = F
pu.check = set.possible.utterances(num.adj.pairs, mods)
if (!pu.check) {
print("Error in listener1: unable to set possible utterances")
}
flip = function(p) {return(runif(1,0,1) < p)}
samples = matrix(NA, nrow=n.samples, ncol=length(possible.utterances), dimnames=list(paste('samp', 1:n.samples, sep=''), c('degree', paste('theta.', possible.utterances[-1], sep=''))))
dens = function(x){return(dnorm(x, 0, 2.25))}
sample.degree = 0
sample.thetas = c(0,0)
sample.prob.NN = 0
while (approx.equal(sample.prob.NN,0) || !admissible(c(sample.degree, sample.thetas))) {
sample.degree = rnorm(1,0,2.25)
sample.degree.prior = dens(sample.degree)
#sample.thetas = runif(length(possible.utterances) - 1, -6, 6)
sample.thetas = c(0,0)
sample.likelihood = speaker1(sample.thetas, sample.degree, alpha, utt.cost)[utterance.index(utterance)]
sample.prob.NN = sample.degree.prior * sample.likelihood
}
sample.vec = c(sample.degree, sample.thetas)
n.proposals.accepted = 0
increment = function(n) {if (n < length(sample.vec)) {return(n+1)} else {return(1)}}
switch = 0
make.proposal = function(v, switch) {
proposal.v = v
proposal.v[switch] = sample(c(proposal.v[switch] + step.size, proposal.v[switch] - step.size), 1)
return(proposal.v)
}
for (i in 1:(n.samples+burn.in)) {
switch = increment(switch)
proposal.vec = make.proposal(sample.vec, switch)
if (admissible(proposal.vec)) {
proposal.degree = proposal.vec[1]
proposal.thetas = proposal.vec[2:length(proposal.vec)]
proposal.degree.prior = dens(proposal.degree)
proposal.likelihood = speaker1(proposal.thetas, proposal.degree, alpha, utt.cost)[utterance.index(utterance)]
proposal.prob.NN = proposal.degree.prior * proposal.likelihood
accept = flip(min(1, proposal.prob.NN/sample.prob.NN))
if (accept && i > burn.in) {
n.proposals.accepted = n.proposals.accepted + 1
sample.vec = proposal.vec
sample.prob.NN = proposal.prob.NN
}
}
if (i > burn.in) {
samples[(i-burn.in),] = sample.vec
}
}
return(list(samples=samples, prop.accepted=n.proposals.accepted/(n.samples)))
}
chain3 = listener1('pos', n.samples, alpha=1, utt.cost=1.5)[[1]][sq,]
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain3[,1])) # degree
lines(density(chain3[,3]), col='red') #theta-pos
summary(chain3)
chain4 = listener1('pos', n.samples=500000, alpha=2, utt.cost=1.5)[[1]][sq,]
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain4[,1])) # degree
lines(density(chain4[,3]), col='red') #theta-pos
chain5 = listener1('pos', n.samples=1500000, alpha=2.5, utt.cost=1.5)[[1]][sq,]
par(mfrow=c(1,1))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain4[,1])) # degree
lines(density(chain4[,3]), col='red') #theta-pos
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.5), col='blue', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='black', lty=3)
lines(density(chain5[,1])) # degree
lines(density(chain5[,3]), col='red') #theta-pos
summary(chain5)
chain6 = listener1('pos', n.samples=1500000, alpha=2.5, utt.cost=1.5)[[1]][sq,]
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.4), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1, col='green', lty=4, lwd=3)
lines(density(c(chain5[,1],chain6[,1])), lwd=3, col='blue', lty=2) # degree
lines(density(c(chain5[,3]), chain6[,3]), col='red', lty=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), col=c('green', 'red', 'black', 'blue'))
summary(chain6)
chain7 = listener1('pos', n.samples=5000000, alpha=2, utt.cost=1.5)[[1]][seq(from=1, to=5000000, by=50),]
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.4), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1, col='green', lty=4, lwd=3)
lines(density(chain7[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain7[,3], col='red', lty=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), col=c('green', 'red', 'black', 'blue'))
lines(density(chain7[,3]), col='red', lty=3) #theta-pos
lines(density(chain7[,3]), col='red', lty=3, lwd=3) #theta-pos
chain8 = listener1('pos', n.samples=1000000, alpha=3, utt.cost=2)[[1]][seq(from=1, to=1500000, by=50),]
chain8 = listener1('pos', n.samples=1000000, alpha=3, utt.cost=2)[[1]][seq(from=1, to=1000000, by=50),]
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.4), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1, col='green', lty=4, lwd=3)
lines(density(chain8[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain8[,3]), col='red', lty=3, lwd=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), col=c('green', 'red', 'black', 'blue'))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.45), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1, col='green', lty=4, lwd=3)
lines(density(chain8[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain8[,3]), col='red', lty=3, lwd=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), col=c('green', 'red', 'black', 'blue'))
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), cex=2, col=c('green', 'red', 'black', 'blue'))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.45), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1, col='green', lty=4, lwd=3)
lines(density(chain8[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain8[,3]), col='red', lty=3, lwd=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), cex=2, col=c('green', 'red', 'black', 'blue'))
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.45), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1, col='green', lty=4, lwd=3)
lines(density(chain8[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain8[,3]), col='red', lty=3, lwd=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), cex=1.5, col=c('green', 'red', 'black', 'blue'))
head(chain8)
small.diff = function(v){return(v[1]-v[3] < .1)}
?apply
sorites.prob = apply(chain8[1:100,], MARGIN=1, FUN=small.diff)
sorites.prob
sorites.prob = mean(apply(chain8[1:100,], MARGIN=1, FUN=small.diff))
sorites.prob
sorites.prob = mean(apply(chain8, MARGIN=1, FUN=small.diff))
sorites.prob
epsilons = seq(from=0, to=1, length.out=21)
sorites.prob = function(epsilon){return(mean(apply(chain8, MARGIN=1, FUN=small.diff)))}
sorites.prob(.1)
sorites.prob.by.epsilon = sapply(epsilons, FUN=sorites.prob)
plot(epsilons, sorites.prob.by.epsilon, xlab="Epsilon", ylab="Probability of second premise")
small.diff = function(epsilon){return(function(v){return(v[1]-v[3] < .1)})}
sorites.prob = function(epsilon){return(mean(apply(chain8, MARGIN=1, FUN=small.diff(epsilon))))}
epsilons = seq(from=0, to=1, length.out=21)
sorites.prob.by.epsilon = sapply(epsilons, FUN=sorites.prob)
plot(epsilons, sorites.prob.by.epsilon, xlab="Epsilon", ylab="Probability of second premise")
sorites.prob.by.epsilon
small.diff = function(epsilon){return(function(v){return(v[1]-v[3] < epsilon)})}
sorites.prob = function(epsilon){return(mean(apply(chain8, MARGIN=1, FUN=small.diff(epsilon))))}
epsilons = seq(from=0, to=1, length.out=21)
sorites.prob.by.epsilon = sapply(epsilons, FUN=sorites.prob)
plot(epsilons, sorites.prob.by.epsilon, xlab="Epsilon", ylab="Probability of second premise")
plot(epsilons, sorites.prob.by.epsilon, col='blue', type='b', pch=19, lwd=3, xlab="Epsilon", ylab="Probability of second premise")
plot(epsilons, sorites.prob.by.epsilon, col='blue', type='b', pch=19, lwd=3, xlab="Epsilon", ylab="Probability of second premise", main="Sorites probability")
sorites.prob = 1 - sorites.prob
sorites.prob.by.epsilon = 1 - sorites.prob.by.epsilon
plot(epsilons, sorites.prob.by.epsilon, col='blue', type='b', pch=19, lwd=3, xlab="Epsilon", ylab="Probability of second premise", main="Sorites probability")
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.45), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=.05, col='green', lty=4, lwd=3)
lines(density(chain8[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain8[,3]), col='red', lty=3, lwd=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), cex=1.5, col=c('green', 'red', 'black', 'blue'))
abline(h=1/12, col='green', lty=4, lwd=3)
curve(dnorm(x, 0, 2.25), xlim=c(-6,6), ylim=c(0,.45), col='black', xlab="Strength prior", ylab="Probability density")
abline(h=1/12, col='green', lty=4, lwd=3)
lines(density(chain8[,1]), lwd=3, col='blue', lty=2) # degree
lines(density(chain8[,3]), col='red', lty=3, lwd=3) #theta-pos
legend('topleft', c('Meaning prior', 'Meaning posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), cex=1.5, col=c('green', 'red', 'black', 'blue'))
legend('topleft', c('Threshold prior', 'Threshold posterior', "QUD prior", "QUD posterior"), lty=c(4, 3, 1, 2), text.col=c('green', 'red', 'black', 'blue'), cex=1.5, col=c('green', 'red', 'black', 'blue'))
played
